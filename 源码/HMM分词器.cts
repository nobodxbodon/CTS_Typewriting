导入 { 创建HMM模型, 位置码, HMM模型 } 来自 "./HMM分词模型";

变量 _模型: HMM模型;

导出 接口 HMM分词 {
    分词(句子文本: 文字): 文字[];
    模型: HMM模型;
}

导出 函数 创建HMM分词(HMM词典路径: 文字): HMM分词 {
    如果 (!_模型) {
        _模型 = 创建HMM模型(HMM词典路径);
    }
    返回 {
        分词,
        模型: _模型
    };
}

导出 函数 分词(句子文本: 文字): 文字[] {
    变量 左 = 0;
    变量 右 = 0;
    变量 结尾 = 句子文本.长度;
    变量 结果: 文字[] = [];

    判断 (右 !== 结尾) {
        如果 (句子文本.字符代码在(右) < 0x80) {
            如果 (左 != 右) {
                内部分词(句子文本.子文本(左, 右), 结果);
            }
            左 = 右;
            运行 {
                右 += 单字结果处理(句子文本.子文本(左)); // 连续 英文
                如果 (右 !== 左) {
                    跳出;
                }
                右 += 数字结果处理(句子文本.子文本(左)); // 连续数字
                如果 (右 !== 左) {
                    跳出;
                }
                右++;
            } 判断 (为假);
            变量 词 = 句子文本.子文本(左, 右);
            结果.压入(词);
            左 = 右;
        }
        否则 {
            右++;
        }
    }
    如果 (左 !== 右) {
        内部分词(句子文本.子文本(左, 右), 结果);
    }
    返回 结果;
}

函数 单字结果处理(句子文本: 文字): 数字 {
    变量 i = 0;
    判断 (句子文本.长度 !== i) {
        常量 x = 句子文本.字符代码在(i);
        如果 (97 <= x && x <= 122 || 65 <= x && x <= 90) {
            i++;
        }
        否则 {
            返回 i;
        }
    }
    返回 i;
}

函数 数字结果处理(句子文本: 文字): 数字 {
    变量 i = 0;

    判断 (句子文本.长度 !== i) {
        常量 x = 句子文本.字符代码在(i);
        如果 (48 <= x && x <= 57 || 46 === x) {
            i++;
        }
        否则 {
            返回 i;
        }
    }
    返回 i;
}

常量 _最小数字 = -3.14e+100;

函数 内部分词(句子文本: 文字, 结果: 文字[]) {
    变量 状态: 数字[] = [];
    维特比算法(句子文本, 状态);
    变量 左 = 0;
    变量 右 = 0;
    循环 (变量 i = 0; i < 状态.长度; i++) {
        如果 (状态[i] === 位置码.尾 || 状态[i] === 位置码.独) {
            右 = i + 1;
            变量 词 = 句子文本.子文本(左, 右);
            结果.压入(词);
            左 = 右;
        }
    }
}

函数 维特比算法(句子文本: 文字, 状态集: 数字[]) {

    变量 Y = 位置码.总;
    变量 X = 句子文本.长度;
    变量 当前: 数字, 以前: 数字, 开始: 数字, 临时: 数字, 结尾E: 数字, 结尾S: 数字;
    变量 路径: 数字[] = [];
    变量 频率: 数字[] = [];

    循环 (变量 y = 0; y < Y; y++) {
        频率[0 + y * X] = _模型.开始概率[y] + _模型.取输出概率(_模型.输出概率表[y], 句子文本.字符代码在(0));
        路径[0 + y * X] = -1;
    }

    变量 输出概率: 数字;

    循环 (变量 x = 1; x < X; x++) {
        循环 (变量 y = 0; y < Y; y++) {
            当前 = x + y * X;
            频率[当前] = _最小数字;
            路径[当前] = 位置码.尾;
            输出概率 = _模型.取输出概率(_模型.输出概率表[y], 句子文本.字符代码在(x));
            循环 (变量 yY = 0; yY < Y; yY++) {
                以前 = x - 1 + yY * X;
                临时 = 频率[以前] + _模型.反向概率[yY][y] + 输出概率;
                如果 (临时 > 频率[当前]) {
                    频率[当前] = 临时;
                    路径[当前] = yY;
                }
            }
        }
    }

    结尾E = 频率[X - 1 + 位置码.尾 * X];
    结尾S = 频率[X - 1 + 位置码.独 * X];
    开始 = 0;

    如果 (结尾E >= 结尾S) {
        开始 = 位置码.尾;
    }
    否则 {
        开始 = 位置码.独;
    }
    循环 (变量 x = X - 1; x >= 0; x--) {
        状态集[x] = 开始;
        开始 = 路径[x + 开始 * X];
    }

}
