/// <引用 路径="../node_modules/@types/支持库/index.d.cts"/>

导入 { 系统 } 来自 "./系统";
导入 { 哈希, 字首哈希, 创建对象, 库内词, 用户词, 分行读文件, 按系数升序 } 来自 "./工具";
导入 { 取拼音索引简拼 } 来自 "./编译拼音";
导入 { 加载汉字拼音, 加载hmm分词器, 词典排序 } 来自 "./词典入库工具";

接口 树节点 {
    下个: 数组类<树节点>;
    当前词: 文字[];
    上个: 树节点;
}

接口 停止树 {
    下个: 映射类<文字, 停止树>;
    当前词: 库内词[];
    上个: 停止树;
}

变量 _总词库索引: 树节点;
变量 _停止词索引: 停止树;
变量 _输入记录库索引: 树节点;

导出 函数 加载词库索引() {
    函数 加载() {
        变量 路径 = 系统.解析路径("../lib/基础词库.utf8");
        变量 内容 = 系统.读文件(路径) 转为 文字;
        变量 读一行 = 分行读(内容);
        _总词库索引 = 创建对象();
        _总词库索引.上个 = 空值;
        判断 (为真) {
            变量 行内容 = 读一行.下个().值;
            如果 (!行内容) {
                跳出;
            }
            否则 {
                变量 拼音组 = 行内容.split("'");
                变量 简拼键组: 数字[] = [];
                循环 (变量 i = 0; i < 拼音组.长度; i++) {
                    如果 (i > 2) {
                        跳出;
                    }
                    简拼键组.压入(字首哈希(取拼音索引简拼(拼音组[i])));
                }
                插入节点(简拼键组, 行内容);
            }
        }
        返回 _总词库索引;
        函数 插入节点(键: 数字[], 值: 文字) {
            变量 当前节点: 树节点 = _总词库索引;
            循环 (变量 i = 0; i < 键.长度; i++) {
                变量 当前 = 键[i];
                如果 (!当前节点.下个) {
                    当前节点.下个 = 新建 数组类();
                }
                如果 (!当前节点.下个[当前]) {
                    变量 下个节点: 树节点 = 创建对象();
                    当前节点.下个[当前] = 下个节点;
                    变量 临时 = 当前节点;
                    当前节点 = 下个节点;
                    当前节点.上个 = 临时;
                }
                否则 {
                    当前节点 = 当前节点.下个[当前];
                }
            }
            (当前节点.当前词 || (当前节点.当前词 = [])).压入(值);
        }
    }
    返回 _总词库索引 || 加载();
}

导出 函数 加载输入记录索引() {
    函数 加载() {
        变量 路径 = 系统.解析路径("../lib/输入记录/输入记录.utf8");
        变量 内容 = 系统.读文件(路径) 转为 文字;
        变量 读一行 = 分行读(内容);
        _输入记录库索引 = 创建对象();
        _输入记录库索引.上个 = 空值;
        判断 (为真) {
            变量 行内容 = 读一行.下个().值;
            如果 (!行内容) {
                跳出;
            }
            否则 {
                变量 拼音组 = 行内容.split("'");
                变量 简拼键组: 数字[] = [];
                循环 (变量 i = 0; i < 拼音组.长度; i++) {
                    简拼键组.压入(字首哈希(取拼音索引简拼(拼音组[i])));
                }
                插入节点(简拼键组, 行内容);
            }
        }
        返回 _输入记录库索引;
        函数 插入节点(键: 数字[], 值: 文字) {
            变量 当前节点: 树节点 = _输入记录库索引;
            循环 (变量 i = 0; i < 键.长度; i++) {
                变量 当前 = 键[i];
                如果 (!当前节点.下个) {
                    当前节点.下个 = 新建 数组类();
                }
                如果 (!当前节点.下个[当前]) {
                    变量 下个节点: 树节点 = 创建对象();
                    当前节点.下个[当前] = 下个节点;
                    变量 临时 = 当前节点;
                    当前节点 = 下个节点;
                    当前节点.上个 = 临时;
                }
                否则 {
                    当前节点 = 当前节点.下个[当前];
                }
            }
            (当前节点.当前词 || (当前节点.当前词 = [])).压入(值);
        }
    }
    返回 _输入记录库索引 || 加载();
}

导出 函数 加载停止词索引() {
    函数 加载() {
        变量 路径 = 系统.解析路径("../lib/停止词词典.utf8");
        变量 内容 = 系统.读文件(路径) 转为 文字;
        变量 读一行 = 分行读(内容);
        _停止词索引 = 创建对象();
        _停止词索引.上个 = 空值;
        判断 (为真) {
            变量 行内容 = 读一行.下个().值;
            如果 (!行内容) {
                跳出;
            }
            否则 {
                变量 分组 = 行内容.split(":");
                变量 拼音组 = 分组[0].split("'");
                变量 词: 库内词 = 创建对象();
                词.拼音 = 分组[0];
                词.文本 = 分组[1];
                词.频率 = 1;
                插入节点(拼音组, 词);
            }
        }
        返回 _停止词索引;
        函数 插入节点(键: 文字[], 值: 库内词) {
            变量 当前节点: 停止树 = _停止词索引;
            循环 (变量 i = 0; i < 键.长度; i++) {
                变量 当前 = 键[i];
                如果 (!当前节点.下个) {
                    当前节点.下个 = 新建 映射类();
                }
                如果 (!当前节点.下个.存在(当前)) {
                    变量 下个节点: 停止树 = 创建对象();
                    当前节点.下个.设置(当前, 下个节点);
                    变量 临时 = 当前节点;
                    当前节点 = 下个节点;
                    当前节点.上个 = 临时;
                }
                否则 {
                    当前节点 = 当前节点.下个.获取(当前);
                }
            }
            (当前节点.当前词 || (当前节点.当前词 = [])).压入(值);
        }
    }
    返回 _停止词索引 || 加载();
}

变量 停止词个数 = 0;

导出 函数 查询拼音数据库(简拼: 文字[], 拼音: 文字, 是全拼?: 真假, 是简拼?: 真假): 库内词[] {
    变量 用户词 = 取输入记录词(简拼, 拼音, 是全拼, 是简拼);
    尝试 {
        变量 库内词 = 取基本库词(简拼, 拼音, 是全拼, 是简拼);
        如果 (用户词 && 库内词) {
            变量 结果:数组类<库内词> = 去除重复(库内词);
            结果.压入(...去除重复(用户词));
            结果 = 去除重复(结果);
            返回 结果.排序(按系数升序);
        }
        否则 {
            返回 去除重复(库内词).排序(按系数升序);
        }
    }
    捕获 (err) {
        如果 (用户词) {
            返回 去除重复(用户词).排序(按系数升序);
        }
        否则 {
            尝试 {
                如果 (停止词个数 > 3) {
                    抛出 新建 错误类("停止词个数太多");
                }
                停止词个数++;
                变量 后面: 库内词[];
                变量 前面: 库内词[];
                变量 起点 = -1;
                变量 i: 数字, 词: 库内词[];
                判断 (起点 !== 0 && 起点 < 简拼.长度) {
                    变量 临时 = 取停止词(拼音.分割("'"), 起点 == -1 ? 起点 = 0 : 起点);
                    i = 临时.i;
                    词 = 临时.词;
                    如果 (词) {
                        跳出;
                    }
                    起点++;
                }
                如果 (起点 !== 0 && 起点 < 简拼.长度) {
                    变量 临时 = [...简拼];
                    变量 临时2 = 拼音;
                    拼音 = 拼音.分割("'").分割(0, 起点).连接("'");
                    前面 = 查询拼音数据库(简拼.分割(0, 起点), 拼音, 是全拼, 是简拼);
                    简拼 = 临时;
                    拼音 = 临时2;
                }
                如果 (词) {
                    如果 (i < 简拼.长度 - 1) {
                        拼音 = 拼音.分割("'").分割(i).连接("'");
                        后面 = 查询拼音数据库(简拼.分割(i), 拼音, 是全拼, 是简拼);
                    }
                    如果 (前面 && 后面) {
                        返回 多维组合成词([前面, 词, 后面]);
                    }
                    否则 如果 (前面) {
                        返回 多维组合成词([前面, 词]);
                    }
                    否则 如果 (后面) {
                        返回 多维组合成词([词, 后面]);
                    }
                    否则 {
                        返回 词;
                    }
                }
                否则 {
                    变量 组合: 库内词[][] = [];
                    变量 临时 = [...简拼];
                    变量 临时2 = 拼音.包括("'") ? 拼音.分割("'") : 拼音;
                    循环 (变量 ii = 0; ii < 临时.长度; ii++) {
                        变量 值 = 查询拼音数据库([临时[ii]], 临时2[ii], 是全拼, 是简拼);
                        组合.压入(值);
                    }
                    返回 多维组合成词(组合);
                }
            }
            捕获 (err) {
                停止词个数 = 0;
                返回 [{ 拼音: 拼音.替换("'", ""), 文本: 拼音, 频率: 1 }];
            }
        }
    }
}

函数 多维组合成词(二维数组: 库内词[][]): 库内词[] {
    变量 结果数组: 库内词[] = [];
    变量 临时: 库内词[] = [];
    变量 长度 = 二维数组.长度;
    函数 交叉组合(多维数组: 库内词[][], 过度: 库内词[] = [], 当前层: 数字 = 0) {
        如果 (多维数组.长度 === 当前层 + 1) {
            循环 (变量 i = 0; i < 多维数组[当前层].长度; i++) {
                临时 = 过度.分裂(0);
                临时.压入(多维数组[当前层][i]);
                变量 组合: 库内词 = 创建对象();
                组合.文本 = "";
                组合.频率 = 0;
                变量 拼音: 文字[] = [];
                循环 (变量 v 属于 临时) {
                    组合.文本 += v.文本;
                    拼音.压入(v.拼音);
                    组合.频率 += (v.频率 / 长度);
                }
                组合.拼音 = 拼音.连接("'");
                结果数组.压入(组合);
            }
        }
        否则 {
            循环 (变量 i = 0; i < 多维数组[当前层].长度; i++) {
                临时 = 过度.分裂(0);
                临时.压入(多维数组[当前层][i]);
                交叉组合(多维数组, 临时, 当前层 + 1);
            }
        }
    }
    交叉组合(二维数组);
    临时 = 未定;
    返回 结果数组;
}

函数 去除重复(数据: 库内词[]) {
    值量 结果: 数组类<库内词> = [];
    循环 (值量 i = 0; i < 数据.长度; i++) {
        如果 (结果.查找索引(v => v.文本 == 数据[i].文本) === -1) {
            结果.压入(数据[i]);
        }
    }
    返回 结果;
}

函数 取基本库词(简拼: 文字[], 拼音: 文字, 是全拼?: 真假, 是简拼?: 真假) {
    变量 结果: 库内词[] = [];
    变量 当前 = _总词库索引;
    循环 (变量 i = 0; i < 简拼.长度; i++) {
        变量 p = 简拼[i];
        变量 键 = 字首哈希(p);
        如果 (当前.下个) {
            如果 (!当前.下个[键]) {
                返回;
            }
            否则 {
                当前 = 当前.下个[键];
            }
        }
        否则 如果 (当前.当前词) {
            结果 = 筛选基本库结果(当前.当前词, 简拼, 拼音, 是全拼, 是简拼);
        }
        否则 {
            返回;
        }
        如果 (i === 简拼.长度 - 1) {
            如果 (当前.当前词) {
                结果 = 筛选基本库结果(当前.当前词, 简拼, 拼音, 是全拼, 是简拼);
            }
        }
    }
    返回 结果 && 结果.长度 ? 结果.排序(按系数升序) : 未定;
}

函数 取输入记录词(简拼: 文字[], 拼音: 文字, 是全拼?: 真假, 是简拼?: 真假) {
    变量 结果: 库内词[] = [];
    变量 当前 = _输入记录库索引;
    循环 (变量 i = 0; i < 简拼.长度; i++) {
        变量 p = 简拼[i];
        变量 键 = 字首哈希(p);
        如果 (当前.下个) {
            如果 (!当前.下个[键]) {
                // 没有下个 从这里取词
            }
            否则 {
                当前 = 当前.下个[键];
            }
        }
        否则 如果 (当前.当前词) {
            变量 词组文本 = 当前.当前词;
            结果 = 筛选输入记录结果组(词组文本, 简拼, 拼音, 是全拼, 是简拼);
        }
        否则 {
            返回;
        }
        如果 (i === 简拼.长度 - 1) {
            如果 (当前.当前词) {
                变量 词组文本 = 当前.当前词;
                结果 = 筛选输入记录结果组(词组文本, 简拼, 拼音, 是全拼, 是简拼);
            }
            否则 {
                返回;
            }
        }
    }
    返回 结果 && 结果.长度 ? 结果 : 未定;
}

函数 取停止词(拼音: 文字[], 起点 = 0): { i: 数字; 词: 库内词[] } {

    变量 结果: 库内词[] = [];
    变量 当前 = _停止词索引;

    如果 (起点 >= 拼音.长度) {
        返回 { i: 0, 词: [] };
    }

    循环 (变量 i = 起点; i < 拼音.长度; i++) {
        变量 键 = 拼音[i];
        如果 (当前.下个) {
            如果 (!当前.下个.存在(键)) {
                判断 (i !== 0) {
                    如果 (当前.当前词) {
                        跳出;
                    }
                    当前 = 当前.上个;
                    i--;
                }
                返回 { i, 词: 当前 && 当前.当前词 };
            }
            否则 {
                当前 = 当前.下个.获取(键);
            }
        }
        否则 {
            判断 (i !== 0) {
                如果 (当前.当前词) {
                    跳出;
                }
                i--;
                当前 = 当前.上个;
            }
            返回 { i, 词: 当前 && 当前.当前词 };
        }
        如果 (i === 拼音.长度 - 1) {
            如果 (当前.当前词) {
                返回 { i, 词: 当前 && 当前.当前词 };
            }
            否则 {
                判断 (i !== 0) {
                    如果 (当前.当前词) {
                        跳出;
                    }
                    i--;
                    当前 = 当前.上个;
                }
                返回 { i, 词: 当前 && 当前.当前词 };
            }
        }
    }
}

变量 _最大值 = (2 ** 53 - 1) / 10000;

函数 计算输入记录频率(使用次数: 数字) {
    返回 数学类.min(使用次数 * 10000, _最大值);
}

函数 筛选输入记录结果组(词组文本: 文字[], 键组: 文字[], 拼音: 文字, 是全拼 = 为假, 是简拼?: 真假) {
    变量 结果: 映射类<文字, 库内词[]> = 新建 映射类();
    创建库内词组();
    如果 (是全拼) {
        如果 (结果.存在(拼音)) {
            返回 结果.获取(拼音);
        }
        否则 {
            返回;
        }
    }
    否则 如果 (结果.存在("#1#")) {
        返回 结果.获取("#1#");
    }
    否则 {
        返回;
    }

    函数 创建库内词组() {
        循环 (变量 t 属于 词组文本) {
            变量 词: 库内词 = 创建对象();
            变量 组 = t.split(":");
            词.拼音 = 组[0];
            词.文本 = 组[1];
            词.频率 = 计算输出频率(计算输入记录频率(+组[2]), 拼音, 组[0], 键组, 是简拼);
            变量 键 = 是全拼 ? 词.拼音 : "#1#";
            如果 (结果.存在(键)) {
                结果.获取(键).压入(词);
            }
            否则 {
                结果.设置(键, [词]);
            }
        }
    }
}

函数 筛选基本库结果(词组文本: 文字[], 键组: 文字[], 拼音: 文字, 是全拼 = 为假, 是简拼?: 真假) {
    变量 结果: 映射类<文字, 库内词[]> = 新建 映射类();
    创建库内词组();

    如果 (是全拼) {
        如果 (结果.存在(拼音)) {
            返回 结果.获取(拼音);
        }
        否则 {
            返回;
        }
    }
    否则 如果 (结果.存在("#1#")) {
        返回 结果.获取("#1#");
    }
    否则 {
        返回;
    }

    函数 创建库内词组() {
        循环 (变量 t 属于 词组文本) {
            变量 词: 库内词 = 创建对象();
            变量 组 = t.split(":");
            词.拼音 = 组[0];
            词.文本 = 组[1];
            词.频率 = 计算输出频率(+组[2], 拼音, 组[0], 键组, 是简拼);
            变量 键 = 是全拼 ? 词.拼音 : "#1#";
            如果 (结果.存在(键)) {
                结果.获取(键).压入(词);
            }
            否则 {
                结果.设置(键, [词]);
            }
        }
    }
}

函数 计算输出频率(基数: 数字, 输入: 文字, 输出: 文字, 键组: 文字[], 是简拼 = 为假) {
    变量 值 = 1;

    如果 (是简拼) {
        返回 基数;
    }
    如果 (输入 === 输出) {
        返回 数学类.ceil(基数) * 2 ** 16;
    }

    变量 a = 输入.分割("'");
    变量 b = 输出.分割("'");
    变量 长度 = 数学类.min(a.长度, b.长度);

    循环 (变量 i = 0; i < 长度; i++) {
        如果 (a[i] === b[i] && a[i] !== 键组[i]) {
            值 += 8;
        }
    }

    如果 (a.长度 === b.长度) {
        值 += 1;
    }

    值 = 值 > 30 ? 30 : 值;

    返回 值 > 2 ? 数学类.ceil(基数) * 数学类.pow(2, 值) : 数学类.ceil(基数 * .1);
}

函数* 分行读(文本: 文字) {
    变量 文本组 = 文本.分割("\r\n");
    循环 (变量 v 属于 文本组) {
        获得 v;
    }
}

导出 函数 存入用户输出记录索引(文本: 文字) {
    更新用户输出索引(文本);
}

函数 更新用户输出索引(词文本: 文字) {

    变量 新词: 用户词[] = [];
    变量 拼音组 = 加载汉字拼音(词文本);

    如果 (拼音组) {
        如果 (拼音组.长度 === 1) {
            变量 拼音 = 拼音组[0];
            变量 拼音分组 = 拼音.分割("'");
            变量 简拼键组: 数字[] = [];
            循环 (变量 i = 0; i < 拼音分组.长度; i++) {
                简拼键组.压入(字首哈希(取拼音索引简拼(拼音分组[i])));
            }
            更新数据(简拼键组, `${拼音}:${词文本}:${1}`);
        }
        否则 {
            拼音组.循环执行(v => {
                变量 拼音分组 = v.分割("'");
                变量 简拼键组: 数字[] = [];
                循环 (变量 i = 0; i < 拼音分组.长度; i++) {
                    简拼键组.压入(字首哈希(取拼音索引简拼(拼音分组[i])));
                }
                更新数据(简拼键组, `${v}:${词文本}:${1}`);
            });
        }
    }

    函数 更新数据(简拼键组: 数字[], 加入文本: 文字) {

        变量 存在 = 取输入记录原始数据(简拼键组);

        如果 (存在) {
            变量 位置 = 存在.查找索引(vv => {
                变量 zu1 = vv.分割(":");
                变量 zu2 = 加入文本.分割(":");
                返回 zu1[0] + zu1[1] === zu2[0] + zu2[1];
            });
            如果 (位置 !== -1) {
                变量 文本 = 存在[位置];
                变量 zu = 文本.分割(":");
                存在[位置] = `${zu[0]}:${zu[1]}:${+zu[2] + 1}`;
            }
            否则 {
                存在.压入(加入文本);
            }
        }
        否则 {
            按库插入节点(_输入记录库索引, 简拼键组, 加入文本);
        }
    }

}

函数 取输入记录原始数据(简拼: 数字[]) {

    变量 当前 = _输入记录库索引;

    循环 (变量 i = 0; i < 简拼.长度; i++) {
        变量 键 = 简拼[i];
        如果 (当前 && 当前.下个) {
            当前 = 当前.下个[键];
        }
        否则 {
            返回;
        }
        如果 (i === 简拼.长度 - 1) {
            如果 (当前 && 当前.当前词) {
                返回 当前.当前词;
            }
        }
    }
    
}

函数 提取输入记录树数据() {
    变量 数据: 文字[] = [];

    函数 深度遍历(节点: 树节点) {
        如果 (节点 != 空值) {
            如果 (节点.当前词) {
                数据.压入(...节点.当前词);
            }
            变量 子节点 = 节点.下个;
            循环 (变量 子键 位于 子节点) {
                深度遍历(子节点[子键]);
            }
        }
    }

    深度遍历(_输入记录库索引);
    返回 数据;
}

导出 函数 保存输入记录() {

    变量 数据 = 提取输入记录树数据();
    变量 词典路径 = 系统.解析路径("../lib/输入记录/输入记录.utf8");
    词典排序(词典路径, 数据.连接(系统.新行));

}

函数 按库插入节点(根节点: 树节点, 键: 数字[], 值: 文字) {

    变量 当前节点: 树节点 = 根节点;
    循环 (变量 i = 0; i < 键.长度; i++) {
        变量 当前 = 键[i];
        如果 (!当前节点.下个) {
            当前节点.下个 = 新建 数组类();
        }
        如果 (!当前节点.下个[当前]) {
            变量 下个节点: 树节点 = 创建对象();
            当前节点.下个[当前] = 下个节点;
            变量 临时 = 当前节点;
            当前节点 = 下个节点;
            当前节点.上个 = 临时;
        }
        否则 {
            当前节点 = 当前节点.下个[当前];
        }
    }
    (当前节点.当前词 || (当前节点.当前词 = [])).压入(值);

}
